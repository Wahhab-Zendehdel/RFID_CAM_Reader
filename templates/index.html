<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RFID Label OCR</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #111825;
      --panel2: #0e1622;
      --text: #f5f7fa;
      --muted: #9aa4b2;
      --accent: #2d8cff;
      --danger: #ff4d4d;
      --ok: #22c55e;
      --border: rgba(255, 255, 255, 0.08);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    .app {
      height: 100vh;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .topbar {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .brand {
      font-weight: 800;
      letter-spacing: 0.2px;
      white-space: nowrap;
    }

    .tabs {
      display: flex;
      gap: 6px;
      padding: 4px;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 12px;
    }

    .tab-btn {
      appearance: none;
      border: 0;
      background: transparent;
      color: var(--muted);
      padding: 10px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: background 120ms ease;
    }

    .tab-btn.active {
      background: rgba(45, 140, 255, 0.18);
      color: var(--text);
    }

    .conn {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 13px;
      white-space: nowrap;
    }

    .dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: var(--danger);
    }

    .dot.ok { background: var(--ok); }

    .content {
      flex: 1 1 auto;
      min-height: 0;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      overflow: hidden;
    }

    .tab-panel {
      height: 100%;
      display: none;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .tab-panel.active {
      display: flex;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      min-height: 0;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="text"] {
      flex: 1 1 auto;
      min-width: 160px;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      outline: none;
      font-size: 14px;
    }

    button.primary {
      border: 0;
      padding: 12px 14px;
      border-radius: 12px;
      background: var(--accent);
      color: white;
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
    }

    button.primary:disabled {
      opacity: 0.55;
      cursor: default;
    }

    button.secondary {
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
    }

    button.secondary.on {
      border-color: rgba(34, 197, 94, 0.6);
      background: rgba(34, 197, 94, 0.18);
    }

    button.danger {
      border: 1px solid rgba(239, 68, 68, 0.5);
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(239, 68, 68, 0.12);
      color: #ff9b9b;
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
    }

    button.danger:disabled {
      opacity: 0.55;
      cursor: default;
    }

    button.secondary:disabled {
      opacity: 0.55;
      cursor: default;
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 11px;
      color: #fff;
    }
    .badge.ok { background: rgba(34, 197, 94, 0.6); }
    .badge.danger { background: rgba(239, 68, 68, 0.7); }
    .badge.warn { background: rgba(234, 179, 8, 0.8); color: #111; }
    .badge.muted { background: rgba(148, 163, 184, 0.5); }
    .hint {
      color: var(--muted);
      font-size: 13px;
    }

    .status {
      min-height: 18px;
      color: var(--muted);
      font-size: 13px;
    }

    .tag-grid {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-wrap: wrap;
      align-content: flex-start;
      gap: 8px;
      overflow: hidden; /* no internal scroll; we cap render count */
    }

    .chip {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      position: relative;
    }

    .chip .label {
      padding: 2px 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.08);
      font-size: 11px;
      color: var(--text);
    }

    .chip .label.missing {
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
    }

    .chip .tag-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .chip .inline-input {
      width: 70px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-size: 12px;
    }

    .chip .chip-status {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: -16px;
      color: var(--danger);
      font-size: 11px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .groups-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: start;
    }

    .group-list {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      min-height: 120px;
      background: rgba(255, 255, 255, 0.03);
    }

    .group-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid var(--border);
      font-size: 12px;
    }
    .group-item:last-child { border-bottom: 0; }

    .group-actions {
      display: flex;
      gap: 6px;
    }

    .pair-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .pair-table th, .pair-table td {
      padding: 6px;
      border-top: 1px solid var(--border);
      vertical-align: middle;
    }

    .pair-table input {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      font-size: 12px;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .row-error {
      color: var(--danger);
      font-size: 11px;
      margin-top: 4px;
    }

    .input-error {
      border-color: var(--danger);
    }

    @media (max-width: 980px) {
      .groups-grid {
        grid-template-columns: 1fr;
      }
    }

    .chip button {
      border: 0;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      width: 22px;
      height: 22px;
      border-radius: 999px;
      cursor: pointer;
      line-height: 22px;
      padding: 0;
    }

    .capture-layout {
      flex: 1 1 auto;
      min-height: 0;
      display: grid;
      grid-template-columns: minmax(220px, 0.85fr) minmax(320px, 1.15fr);
      grid-template-rows: auto auto 1fr;
      gap: 12px;
    }

    .events-panel {
      grid-column: 1 / 3;
    }

    .kv {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 6px 10px;
      font-size: 13px;
    }

    .kv .k { color: var(--muted); }
    .kv .v {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .number {
      margin-top: 10px;
      text-align: center;
      padding: 14px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.22);
      font-size: clamp(40px, 5vw, 64px);
      font-weight: 900;
      letter-spacing: 4px;
    }

    .alert {
      margin-top: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      font-weight: 700;
      color: var(--text);
    }

    .alert.ok { border-color: rgba(34, 197, 94, 0.5); background: rgba(34, 197, 94, 0.14); }
    .alert.warn { border-color: rgba(234, 179, 8, 0.5); background: rgba(234, 179, 8, 0.14); }
    .alert.danger { border-color: rgba(239, 68, 68, 0.6); background: rgba(239, 68, 68, 0.16); }
    .alert.muted { color: var(--muted); }

    .images {
      min-height: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .image-box {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .image-title {
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
    }

    .imgwrap {
      flex: 1 1 auto;
      min-height: 0;
      border-radius: 12px;
      border: 1px dashed var(--border);
      background: rgba(0, 0, 0, 0.18);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    th, td {
      text-align: left;
      padding: 8px 8px;
      border-top: 1px solid var(--border);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    th {
      color: var(--muted);
      font-weight: 700;
      border-top: 0;
    }

    @media (max-width: 980px) {
      .images { grid-template-columns: 1fr; grid-template-rows: 1fr 1fr; }
      .kv { grid-template-columns: 120px 1fr; }
    }

    details.panel {
      padding-top: 6px;
    }
    details summary {
      cursor: pointer;
      font-weight: 700;
      color: var(--text);
      list-style: none;
      outline: none;
      margin-bottom: 6px;
    }
    details summary::-webkit-details-marker { display: none; }
    details .kv { margin-top: 4px; }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">RFID Label OCR</div>

      <nav class="tabs" aria-label="Tabs">
        <button class="tab-btn active" data-tab="tags" type="button">Approved Tags</button>
        <button class="tab-btn" data-tab="capture" type="button">RFID Capture</button>
      </nav>

      <div class="conn" id="conn">
        <span class="dot" id="conn-dot"></span>
        <span id="conn-text">RFID: ...</span>
      </div>
    </header>

    <main class="content">
      <section class="tab-panel active" id="tab-tags">
        <div class="panel">
          <div class="row">
            <input id="tag-input" type="text" placeholder="Enter EPC/UID (hex) ..." autocomplete="off" />
            <input id="tag-label-input" type="text" placeholder="5-digit label (e.g., 12345)" maxlength="5" autocomplete="off" />
            <button class="primary" id="add-tag-btn" type="button">Add Tag</button>
            <button class="secondary" id="listen-btn" type="button">Listening: OFF</button>
          </div>
          <div class="status" id="tags-status"></div>
          <div class="hint" id="tags-meta">Approved tags: 0</div>
        </div>

        <div class="panel" style="flex: 1 1 auto; min-height: 0;">
          <div class="hint" style="margin-bottom: 10px;">Approved tag list (stored in <code>approved_tags.json</code>)</div>
          <div class="tag-grid" id="tags"></div>
        </div>

        <div class="panel">
          <div class="panel-header">
            <div class="hint">Groups â€” Create / Edit Group</div>
            <button class="secondary" id="group-refresh-btn" type="button">Refresh</button>
          </div>
          <div class="groups-grid">
            <div>
              <div class="group-list" id="group-list"></div>
            </div>
            <div>
              <div class="row">
                <input id="group-name" type="text" placeholder="Group name (required)" />
                <input id="group-id" type="text" placeholder="Group ID (optional, e.g., G-001)" />
              </div>
              <div class="row" style="margin-top: 8px;">
                <label style="display:flex; gap:6px; align-items:center; font-size:12px;">
                  <input type="checkbox" id="group-enabled" checked /> Enabled
                </label>
                <input id="group-tag-window" type="text" placeholder="Tag window seconds" value="5.0" />
                <label style="display:flex; gap:6px; align-items:center; font-size:12px;">
                  <input type="checkbox" id="group-strict-tags" checked /> Strict tags
                </label>
                <label style="display:flex; gap:6px; align-items:center; font-size:12px;">
                  <input type="checkbox" id="group-strict-labels" checked /> Strict labels
                </label>
              </div>

              <div class="row" style="margin-top: 8px;">
                <select id="group-add-tag" style="flex:1 1 auto; padding:10px; border-radius:10px; border:1px solid var(--border); background:rgba(255,255,255,0.04); color:var(--text);">
                  <option value="">Add approved tag...</option>
                </select>
                <button class="secondary" id="group-add-tag-btn" type="button">Add to Group</button>
              </div>

              <table class="pair-table" style="margin-top: 8px;">
                <thead>
                  <tr>
                    <th>Tag</th>
                    <th>Label (5 digits)</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody id="group-pairs-body"></tbody>
              </table>

              <div class="row" style="margin-top: 8px;">
                <button class="secondary" id="group-add-row" type="button">Add Row</button>
                <button class="primary" id="group-create" type="button">Create Group</button>
                <button class="primary" id="group-update" type="button" style="display:none;">Update Group</button>
                <button class="secondary" id="group-clear" type="button">Clear</button>
              </div>
              <div class="status" id="group-editor-status"></div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" id="tab-capture">
        <div class="capture-layout">
          <div class="panel" style="grid-row: 1; grid-column: 1;">
            <div class="hint" id="approved-count">Approved tags: 0</div>
            <div class="row" style="margin: 6px 0;">
              <select id="group-select" style="flex:1 1 auto; padding:10px; border-radius:10px; border:1px solid var(--border); background:rgba(255,255,255,0.04); color:var(--text);">
                <option value="">Select group...</option>
              </select>
              <button class="secondary" id="group-start-btn" type="button">Start Group</button>
              <button class="secondary" id="group-stop-btn" type="button">Stop</button>
            </div>
            <div class="status" id="group-status">No active group.</div>
            <div class="kv" style="margin-top: 10px;">
              <div class="k">Last RFID tag</div><div class="v" id="last-tag">-</div>
              <div class="k">Approved</div><div class="v" id="last-approved">-</div>
              <div class="k">For tag</div><div class="v" id="cap-tag">-</div>
              <div class="k">Expected</div><div class="v" id="cap-expected">-</div>
              <div class="k">Observed</div><div class="v" id="cap-observed">-</div>
              <div class="k">Match status</div><div class="v" id="cap-match">-</div>
              <div class="k">Attempt</div><div class="v" id="cap-attempt">0 / -</div>
              <div class="k">Message</div><div class="v" id="cap-msg">-</div>
            </div>

            <div class="alert muted" id="cap-banner" aria-live="polite">Waiting for approved RFID tag...</div>
            <div class="number" id="cap-number">-----</div>
            <div class="status" id="cap-sub">Waiting for approved RFID tag...</div>
            <div class="row" style="margin-top: 6px;">
              <button class="primary" id="submit-btn" type="button" disabled>Submit capture</button>
              <button class="danger" id="retry-btn" type="button" disabled>Try Again</button>
              <div class="hint" id="submit-status">Capture must succeed before submit.</div>
            </div>
          </div>

          <div class="panel" style="grid-row: 1; grid-column: 2;">
            <div class="images" style="margin-top: 4px;">
              <div class="image-box">
                <div class="image-title" id="title-original">Original (outline)</div>
                <div class="imgwrap"><img id="img-original" alt="Original frame" /></div>
              </div>
              <div class="image-box">
                <div class="image-title" id="title-paper">Warped paper</div>
                <div class="imgwrap"><img id="img-paper" alt="Warped paper" /></div>
              </div>
              <div class="image-box">
                <div class="image-title" id="title-secondary">Secondary camera</div>
                <div class="imgwrap"><img id="img-secondary" alt="Secondary camera frame" /></div>
              </div>
            </div>

            <details class="panel" style="margin-top: 12px;">
              <summary>Show details</summary>
              <div class="kv">
                <div class="k">Queue</div><div class="v" id="queue-size">0</div>
                <div class="k">Capture</div><div class="v" id="cap-state">idle</div>
                <div class="k">Attempt reset</div><div class="v" id="cap-attempt-reset">-</div>
                <div class="k">Secondary mode</div><div class="v" id="cap-secondary-mode">-</div>
              </div>
            </details>
          </div>

          <div class="panel" style="grid-row: 2; grid-column: 1;">
            <div class="hint" style="margin-bottom: 8px;">Active tags / Group</div>
            <div class="status" id="group-sets-summary">Required/Seen/OCR sets</div>
            <table>
              <thead>
                <tr>
                  <th>Tag</th>
                  <th>Expected</th>
                  <th>Observed</th>
                  <th>State</th>
                  <th>Attempt</th>
                </tr>
              </thead>
              <tbody id="active-tags-body"></tbody>
            </table>
          </div>

          <div class="panel" style="grid-row: 2; grid-column: 2;">
            <div class="hint" style="margin-bottom: 8px;">Mismatches</div>
            <div id="mismatch-list" class="status">No mismatches.</div>
          </div>

          <div class="panel events-panel" style="grid-row: 3; grid-column: 1 / 3;">
            <div class="hint" style="margin-bottom: 8px;">Recent events</div>
            <table>
              <thead>
                <tr>
                  <th style="width: 90px;">Type</th>
                  <th style="width: 120px;">Time (UTC)</th>
                  <th>Tag / Info</th>
                </tr>
              </thead>
              <tbody id="events"></tbody>
            </table>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    const tabButtons = Array.from(document.querySelectorAll(".tab-btn"));
    const tabPanels = {
      tags: document.getElementById("tab-tags"),
      capture: document.getElementById("tab-capture"),
    };

    const connDot = document.getElementById("conn-dot");
    const connText = document.getElementById("conn-text");

    const tagInput = document.getElementById("tag-input");
    const tagLabelInput = document.getElementById("tag-label-input");
    const addTagBtn = document.getElementById("add-tag-btn");
    const listenBtn = document.getElementById("listen-btn");
    const tagsStatus = document.getElementById("tags-status");
    const tagsMeta = document.getElementById("tags-meta");
    const tagsContainer = document.getElementById("tags");

    const approvedCount = document.getElementById("approved-count");
    const lastTag = document.getElementById("last-tag");
    const lastApproved = document.getElementById("last-approved");
    const queueSize = document.getElementById("queue-size");
    const capState = document.getElementById("cap-state");
    const capTag = document.getElementById("cap-tag");
    const capAttempt = document.getElementById("cap-attempt");
    const capAttemptReset = document.getElementById("cap-attempt-reset");
    const capSecondaryMode = document.getElementById("cap-secondary-mode");
    const capExpected = document.getElementById("cap-expected");
    const capObserved = document.getElementById("cap-observed");
    const capMatch = document.getElementById("cap-match");
    const capMsg = document.getElementById("cap-msg");
    const capNumber = document.getElementById("cap-number");
    const capBanner = document.getElementById("cap-banner");
    const capSub = document.getElementById("cap-sub");
    const submitBtn = document.getElementById("submit-btn");
    const retryBtn = document.getElementById("retry-btn");
    const submitStatus = document.getElementById("submit-status");
    const imgOriginal = document.getElementById("img-original");
    const imgPaper = document.getElementById("img-paper");
    const imgSecondary = document.getElementById("img-secondary");
    const titleOriginal = document.getElementById("title-original");
    const titlePaper = document.getElementById("title-paper");
    const titleSecondary = document.getElementById("title-secondary");
    const eventsBody = document.getElementById("events");
    const activeTagsBody = document.getElementById("active-tags-body");
    const mismatchList = document.getElementById("mismatch-list");
    const groupSelect = document.getElementById("group-select");
    const groupStartBtn = document.getElementById("group-start-btn");
    const groupStopBtn = document.getElementById("group-stop-btn");
    const groupStatus = document.getElementById("group-status");
    const groupSetsSummary = document.getElementById("group-sets-summary");
    const groupList = document.getElementById("group-list");
    const groupNameInput = document.getElementById("group-name");
    const groupIdInput = document.getElementById("group-id");
    const groupEnabledInput = document.getElementById("group-enabled");
    const groupTagWindowInput = document.getElementById("group-tag-window");
    const groupStrictTagsInput = document.getElementById("group-strict-tags");
    const groupStrictLabelsInput = document.getElementById("group-strict-labels");
    const groupAddTagSelect = document.getElementById("group-add-tag");
    const groupAddTagBtn = document.getElementById("group-add-tag-btn");
    const groupPairsBody = document.getElementById("group-pairs-body");
    const groupAddRowBtn = document.getElementById("group-add-row");
    const groupCreateBtn = document.getElementById("group-create");
    const groupUpdateBtn = document.getElementById("group-update");
    const groupClearBtn = document.getElementById("group-clear");
    const groupRefreshBtn = document.getElementById("group-refresh-btn");
    const groupEditorStatus = document.getElementById("group-editor-status");

    let activeTab = "tags";
    let pollInFlight = false;
    let listenEnabled = false;
    let lastScannedTime = Date.now() / 1000;
    let lastListenedTag = "";
    let lastListenTs = 0;
    const LISTEN_DEBOUNCE_SECONDS = 1.0;
    let lastCaptureStatus = {};
    let groupsCache = [];
    let approvedTagEntries = [];
    let tagLabelMap = {};
    let editingGroupId = "";
    function buildActiveTags(c) {
      if (Array.isArray(c.active_tags) && c.active_tags.length) return c.active_tags;
      const legacyTag = c.tag || "";
      if (!legacyTag) return [];
      return [
        {
          tag: legacyTag,
          expected_number: c.expected_number || "",
          observed_number: c.observed_number || c.number || "",
          state: c.state || "pending",
          mismatch: !!c.mismatch,
          message: c.message || "",
          attempt: c.attempt || 0,
          max_attempts: c.max_attempts || 0,
        },
      ];
    }

    function setActiveTab(name) {
      activeTab = name;
      tabButtons.forEach((b) => b.classList.toggle("active", b.dataset.tab === name));
      Object.entries(tabPanels).forEach(([key, el]) => el.classList.toggle("active", key === name));
      if (name !== "tags") setListening(false);
    }

    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
    });

    function setListening(enabled) {
      listenEnabled = !!enabled;
      listenBtn.classList.toggle("on", listenEnabled);
      listenBtn.textContent = listenEnabled ? "Listening: ON" : "Listening: OFF";
      lastScannedTime = listenEnabled ? Date.now() / 1000 : 0;
      lastListenedTag = "";
      lastListenTs = 0;
      if (listenEnabled) {
        tagsStatus.textContent = "Listening... present a tag to the reader.";
      }
    }

    listenBtn.addEventListener("click", () => {
      setListening(!listenEnabled);
    });

    async function fetchJson(url, options) {
      const resp = await fetch(url, options);
      const data = await resp.json().catch(() => null);
      if (!resp.ok) {
        const msg = data && data.message ? data.message : resp.statusText;
        throw new Error(msg);
      }
      return data;
    }

    function normalizeTagsResponse(data) {
      const labelMaps = {};
      if (data && typeof data === "object") {
        Object.assign(labelMaps, data.tag_labels || {});
        Object.assign(labelMaps, data.tag_to_label || {});
      }

      let tagsRaw = [];
      if (Array.isArray(data)) {
        tagsRaw = data;
      } else if (Array.isArray(data?.tags)) {
        tagsRaw = data.tags;
      } else if (Array.isArray(data?.entries)) {
        tagsRaw = data.entries;
      } else if (labelMaps && Object.keys(labelMaps).length > 0) {
        tagsRaw = Object.keys(labelMaps);
      }

      const entries = [];
      for (const item of tagsRaw) {
        if (typeof item === "string") {
          entries.push({ tag: item, label: labelMaps[item] || "" });
        } else if (item && typeof item === "object") {
          const t = item.tag || item.id || item.tag_id;
          if (!t) continue;
          entries.push({ tag: t, label: item.label || labelMaps[t] || "" });
        }
      }

      for (const [t, lbl] of Object.entries(labelMaps)) {
        const exists = entries.some((e) => e.tag === t);
        if (!exists) entries.push({ tag: t, label: lbl });
      }

      const uniq = [];
      const seen = new Set();
      for (const e of entries) {
        if (!e.tag || seen.has(e.tag)) continue;
        seen.add(e.tag);
        uniq.push(e);
      }
      return uniq;
    }

    function renderTags(resp) {
      const entries = normalizeTagsResponse(resp);
      approvedTagEntries = entries;
      tagLabelMap = {};
      entries.forEach((e) => {
        if (e.tag) tagLabelMap[e.tag] = e.label || "";
      });
      const MAX_RENDER = 50;
      const shown = entries.slice(0, MAX_RENDER);
      tagsContainer.innerHTML = "";

      for (const entry of shown) {
        const tag = entry.tag;
        const label = entry.label || "";
        const chip = document.createElement("div");
        chip.className = "chip";

        const text = document.createElement("span");
        text.textContent = tag;
        chip.appendChild(text);

        const labelSpan = document.createElement("span");
        labelSpan.className = "label" + (label ? "" : " missing");
        labelSpan.textContent = label || "No label";
        chip.appendChild(labelSpan);

        const inlineInput = document.createElement("input");
        inlineInput.className = "inline-input";
        inlineInput.type = "text";
        inlineInput.maxLength = 5;
        inlineInput.placeholder = "12345";
        inlineInput.value = label;

        const saveBtn = document.createElement("button");
        saveBtn.type = "button";
        saveBtn.textContent = "ðŸ’¾";
        saveBtn.title = "Save label";

        const del = document.createElement("button");
        del.type = "button";
        del.textContent = "x";
        del.title = "Remove";

        const statusSpan = document.createElement("div");
        statusSpan.className = "chip-status";
        statusSpan.textContent = "";

        async function saveLabel() {
          const val = inlineInput.value.trim();
          if (!/^\d{5}$/.test(val)) {
            statusSpan.textContent = "Label must be 5 digits";
            return;
          }
          statusSpan.textContent = "";
          saveBtn.disabled = true;
          inlineInput.disabled = true;
          try {
            await fetchJson(`/api/tags/${encodeURIComponent(tag)}/label`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ label: val }),
            });
            await refreshTags();
          } catch (e) {
            statusSpan.textContent = String(e.message || e);
          } finally {
            saveBtn.disabled = false;
            inlineInput.disabled = false;
          }
        }

        saveBtn.addEventListener("click", saveLabel);
        inlineInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") saveLabel();
        });

        del.addEventListener("click", async () => {
          try {
            await fetchJson("/api/tags/" + encodeURIComponent(tag), { method: "DELETE" });
            await refreshTags();
          } catch (e) {
            tagsStatus.textContent = String(e.message || e);
          }
        });

        const actions = document.createElement("div");
        actions.className = "tag-actions";
        actions.appendChild(inlineInput);
        actions.appendChild(saveBtn);
        actions.appendChild(del);

        chip.appendChild(actions);
        chip.appendChild(statusSpan);
        tagsContainer.appendChild(chip);
      }

      const extra = entries.length > MAX_RENDER ? ` (showing ${MAX_RENDER} of ${entries.length})` : "";
      tagsMeta.textContent = `Approved tags: ${entries.length}${extra}`;

      groupAddTagSelect.innerHTML = '<option value="">Add from approved tags...</option>';
      for (const entry of entries) {
        const opt = document.createElement("option");
        opt.value = entry.tag;
        const labelText = entry.label ? entry.label : "No label";
        opt.textContent = `${entry.tag} â€” ${labelText}`;
        groupAddTagSelect.appendChild(opt);
      }
    }

    async function refreshTags() {
      try {
        const data = await fetchJson("/api/tags");
        renderTags(data);
      } catch (e) {
        tagsStatus.textContent = String(e.message || e);
      }
    }

    async function addTag() {
      const tag = tagInput.value.trim();
      const label = tagLabelInput.value.trim();
      if (!tag) return;
      if (label && !/^\d{5}$/.test(label)) {
        tagsStatus.textContent = "Label must be exactly 5 digits.";
        return;
      }
      addTagBtn.disabled = true;
      tagsStatus.textContent = "";
      try {
        await fetchJson("/api/tags", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(label ? { tag, label } : { tag }),
        });
        tagInput.value = "";
        tagLabelInput.value = "";
        await refreshTags();
      } catch (e) {
        tagsStatus.textContent = String(e.message || e);
      } finally {
        addTagBtn.disabled = false;
      }
    }

    addTagBtn.addEventListener("click", addTag);
    tagInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addTag();
    });
    tagLabelInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addTag();
    });

    async function loadGroups() {
      try {
        const data = await fetchJson("/api/groups");
        groupsCache = data.groups || [];
        groupSelect.innerHTML = '<option value="">Select group...</option>';
        for (const g of groupsCache) {
          const opt = document.createElement("option");
          opt.value = g.group_id || "";
          opt.textContent = `${g.group_id || ""} ${g.name ? "- " + g.name : ""}`.trim();
          groupSelect.appendChild(opt);
        }
        renderGroupList();
      } catch (e) {
        groupStatus.textContent = `Failed to load groups: ${String(e.message || e)}`;
      }
    }

    async function startGroup() {
      const gid = groupSelect.value;
      if (!gid) {
        groupStatus.textContent = "Select a group first.";
        return;
      }
      groupStartBtn.disabled = true;
      try {
        await fetchJson(`/api/groups/${encodeURIComponent(gid)}/start`, { method: "POST" });
        groupStatus.textContent = `Group ${gid} started.`;
      } catch (e) {
        groupStatus.textContent = `Failed to start: ${String(e.message || e)}`;
      } finally {
        groupStartBtn.disabled = false;
      }
    }

    async function stopGroup() {
      groupStopBtn.disabled = true;
      try {
        await fetchJson("/api/groups/stop", { method: "POST" });
        groupStatus.textContent = "Group stopped.";
      } catch (e) {
        groupStatus.textContent = `Failed to stop: ${String(e.message || e)}`;
      } finally {
        groupStopBtn.disabled = false;
      }
    }

    groupStartBtn.addEventListener("click", startGroup);
    groupStopBtn.addEventListener("click", stopGroup);

    function renderGroupList() {
      groupList.innerHTML = "";
      if (!groupsCache.length) {
        groupList.innerHTML = '<div class="hint">No groups yet.</div>';
        return;
      }
      for (const g of groupsCache) {
        const item = document.createElement("div");
        item.className = "group-item";
        const info = document.createElement("div");
        info.textContent = `${g.group_id || ""} ${g.name ? "- " + g.name : ""} (${(g.required_pairs || []).length} pairs)`;
        const actions = document.createElement("div");
        actions.className = "group-actions";
        const enabled = document.createElement("input");
        enabled.type = "checkbox";
        enabled.checked = g.enabled !== false;
        enabled.title = "Enabled";
        enabled.addEventListener("change", async () => {
          const payload = { ...g, enabled: enabled.checked };
          try {
            await fetchJson(`/api/groups/${encodeURIComponent(g.group_id)}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            await loadGroups();
          } catch (e) {
            groupEditorStatus.textContent = `Failed to update: ${String(e.message || e)}`;
          }
        });
        const edit = document.createElement("button");
        edit.className = "secondary";
        edit.type = "button";
        edit.textContent = "Edit";
        edit.addEventListener("click", () => setGroupEditor(g));
        const del = document.createElement("button");
        del.className = "secondary";
        del.type = "button";
        del.textContent = "Delete";
        del.addEventListener("click", async () => {
          if (!confirm(`Delete group ${g.group_id}?`)) return;
          try {
            await fetchJson(`/api/groups/${encodeURIComponent(g.group_id)}`, { method: "DELETE" });
            if (editingGroupId === g.group_id) clearGroupEditor();
            await loadGroups();
          } catch (e) {
            groupEditorStatus.textContent = `Failed to delete: ${String(e.message || e)}`;
          }
        });
        actions.appendChild(enabled);
        actions.appendChild(edit);
        actions.appendChild(del);
        item.appendChild(info);
        item.appendChild(actions);
        groupList.appendChild(item);
      }
    }

    function addPairRow(tagVal = "", labelVal = "", readOnlyTag = false) {
      const tr = document.createElement("tr");
      const tdTag = document.createElement("td");
      const tdLabel = document.createElement("td");
      const tdRemove = document.createElement("td");
      const tagInput = document.createElement("input");
      tagInput.type = "text";
      tagInput.value = tagVal;
      tagInput.readOnly = readOnlyTag;
      const labelInput = document.createElement("input");
      labelInput.type = "text";
      labelInput.maxLength = 5;
      labelInput.value = labelVal;
      const errorDiv = document.createElement("div");
      errorDiv.className = "row-error";
      const removeBtn = document.createElement("button");
      removeBtn.className = "secondary";
      removeBtn.type = "button";
      removeBtn.textContent = "Remove";
      removeBtn.addEventListener("click", () => {
        tr.remove();
        validateGroupEditor();
      });
      tagInput.addEventListener("input", validateGroupEditor);
      labelInput.addEventListener("input", validateGroupEditor);
      tdTag.appendChild(tagInput);
      tdLabel.appendChild(labelInput);
      tdLabel.appendChild(errorDiv);
      tdRemove.appendChild(removeBtn);
      tr.append(tdTag, tdLabel, tdRemove);
      groupPairsBody.appendChild(tr);
      validateGroupEditor();
    }

    function clearGroupEditor() {
      editingGroupId = "";
      groupNameInput.value = "";
      groupIdInput.value = "";
      groupIdInput.disabled = false;
      groupEnabledInput.checked = true;
      groupTagWindowInput.value = "5.0";
      groupStrictTagsInput.checked = true;
      groupStrictLabelsInput.checked = true;
      groupPairsBody.innerHTML = "";
      groupCreateBtn.style.display = "inline-flex";
      groupUpdateBtn.style.display = "none";
      groupEditorStatus.textContent = "";
      validateGroupEditor(false);
    }

    function setGroupEditor(g) {
      editingGroupId = g.group_id || "";
      groupNameInput.value = g.name || "";
      groupIdInput.value = g.group_id || "";
      groupIdInput.disabled = true;
      groupEnabledInput.checked = g.enabled !== false;
      const settings = g.settings || {};
      groupTagWindowInput.value = settings.tag_window_seconds ?? 5.0;
      groupStrictTagsInput.checked = settings.strict_tag_set !== false;
      groupStrictLabelsInput.checked = settings.strict_label_set !== false;
      groupPairsBody.innerHTML = "";
      (g.required_pairs || []).forEach((p) => addPairRow(p.tag || "", p.label || ""));
      groupCreateBtn.style.display = "none";
      groupUpdateBtn.style.display = "inline-flex";
      groupEditorStatus.textContent = "";
      validateGroupEditor(false);
    }

    function generateGroupId() {
      let max = 0;
      groupsCache.forEach((g) => {
        const m = String(g.group_id || "").match(/G-(\d+)/);
        if (m) max = Math.max(max, parseInt(m[1], 10));
      });
      return `G-${String(max + 1).padStart(3, "0")}`;
    }

    function validateGroupEditor(showStatus = true) {
      let error = "";
      const name = groupNameInput.value.trim();
      const rows = Array.from(groupPairsBody.querySelectorAll("tr"));
      const pairs = [];
      const tagCounts = {};
      const labelCounts = {};

      rows.forEach((tr) => {
        const inputs = tr.querySelectorAll("input");
        const tagVal = (inputs[0].value || "").trim().toUpperCase();
        const labelVal = (inputs[1].value || "").trim();
        if (tagVal) tagCounts[tagVal] = (tagCounts[tagVal] || 0) + 1;
        if (labelVal) labelCounts[labelVal] = (labelCounts[labelVal] || 0) + 1;
      });

      rows.forEach((tr) => {
        const inputs = tr.querySelectorAll("input");
        const tagInput = inputs[0];
        const labelInput = inputs[1];
        const err = tr.querySelector(".row-error");
        const tagVal = (tagInput.value || "").trim().toUpperCase();
        const labelVal = (labelInput.value || "").trim();
        let rowError = "";
        tagInput.classList.remove("input-error");
        labelInput.classList.remove("input-error");
        if (!tagVal) {
          rowError = "Tag is required.";
          tagInput.classList.add("input-error");
        } else if (tagCounts[tagVal] > 1) {
          rowError = "Duplicate tag.";
          tagInput.classList.add("input-error");
        }

        if (!labelVal) {
          rowError = rowError || "Label is required.";
          labelInput.classList.add("input-error");
        } else if (!/^\d{5}$/.test(labelVal)) {
          rowError = rowError || "Label must be 5 digits.";
          labelInput.classList.add("input-error");
        } else if (labelCounts[labelVal] > 1) {
          rowError = rowError || "Duplicate label.";
          labelInput.classList.add("input-error");
        }

        if (err) err.textContent = rowError;
        if (!rowError && tagVal && labelVal) {
          pairs.push({ tag: tagVal, label: labelVal });
        }
      });

      if (!name) error = "Group name is required.";
      if (!pairs.length) error = error || "Group must have at least one pair.";

      groupCreateBtn.disabled = !!error;
      groupUpdateBtn.disabled = !!error;
      if (showStatus) groupEditorStatus.textContent = error;
      return { pairs, error };
    }

    async function saveGroup(isUpdate) {
      groupEditorStatus.textContent = "";
      const name = groupNameInput.value.trim();
      let groupId = groupIdInput.value.trim();
      if (!groupId) {
        groupId = generateGroupId();
        groupIdInput.value = groupId;
      }
      const enabled = !!groupEnabledInput.checked;
      const tagWindow = parseFloat(groupTagWindowInput.value || "5.0");
      const strictTags = !!groupStrictTagsInput.checked;
      const strictLabels = !!groupStrictLabelsInput.checked;
      const { pairs, error } = validateGroupEditor(true);
      if (error) {
        return;
      }
      const payload = {
        group_id: groupId,
        name,
        enabled,
        required_pairs: pairs,
        settings: {
          tag_window_seconds: tagWindow,
          strict_tag_set: strictTags,
          strict_label_set: strictLabels,
        },
      };
      try {
        if (isUpdate && editingGroupId) {
          await fetchJson(`/api/groups/${encodeURIComponent(editingGroupId)}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          groupEditorStatus.textContent = "Group updated.";
        } else {
          await fetchJson("/api/groups", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          groupEditorStatus.textContent = "Group created.";
          clearGroupEditor();
        }
        await loadGroups();
      } catch (e) {
        groupEditorStatus.textContent = `Save failed: ${String(e.message || e)}`;
      }
    }

    groupAddRowBtn.addEventListener("click", () => addPairRow());
    groupClearBtn.addEventListener("click", clearGroupEditor);
    groupCreateBtn.addEventListener("click", () => saveGroup(false));
    groupUpdateBtn.addEventListener("click", () => saveGroup(true));
    groupAddTagBtn.addEventListener("click", () => {
      const tag = groupAddTagSelect.value;
      if (!tag) return;
      const existing = Array.from(groupPairsBody.querySelectorAll("tr")).some((tr) => {
        const input = tr.querySelector("input");
        return input && input.value.trim().toUpperCase() === tag.trim().toUpperCase();
      });
      if (existing) {
        groupEditorStatus.textContent = "Tag already added to this group.";
        return;
      }
      addPairRow(tag, tagLabelMap[tag] || "", true);
    });
    groupRefreshBtn.addEventListener("click", loadGroups);

    [groupNameInput, groupIdInput, groupTagWindowInput, groupStrictTagsInput, groupStrictLabelsInput].forEach((el) => {
      el.addEventListener("input", () => validateGroupEditor(false));
      el.addEventListener("change", () => validateGroupEditor(false));
    });

    async function submitCapture() {
      submitBtn.disabled = true;
      submitStatus.textContent = "Submitting...";
      try {
        const resp = await fetchJson("/api/capture/submit", { method: "POST" });
        const saved = resp.saved || {};
        const files = saved.files || {};
        const path = files.json || "";
        const prefix = saved.prefix || "";
        if (path) submitStatus.textContent = `Saved: ${path}`;
        else if (prefix) submitStatus.textContent = `Submitted (${prefix})`;
        else submitStatus.textContent = "Submitted.";
      } catch (e) {
        submitStatus.textContent = `Submit failed: ${String(e.message || e)}`;
      } finally {
        // button state is refreshed by pollStatus
      }
    }

    submitBtn.addEventListener("click", submitCapture);

    async function requestRetry() {
      retryBtn.disabled = true;
      submitBtn.disabled = true;
      submitStatus.textContent = "Retry requested...";
      let tag = (lastCaptureStatus.tag || "").trim();
      const act = buildActiveTags(lastCaptureStatus);
      if (act.length) {
        const unresolved = act.find((t) => t.state && t.state !== "matched");
        tag = (unresolved && unresolved.tag) || act[0].tag || tag;
      }
      if (!tag) {
        submitStatus.textContent = "No active tag to retry.";
        return;
      }
      try {
        await fetchJson("/api/capture/retry", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tag, reason: "operator_retry" }),
        });
        submitStatus.textContent = "Retry requested. Waiting for result...";
      } catch (e) {
        submitStatus.textContent = `Retry failed: ${String(e.message || e)}`;
      }
    }

    retryBtn.addEventListener("click", requestRetry);

    function setConn(connected, enabled, msg) {
      connDot.classList.toggle("ok", !!connected);
      connText.textContent = enabled ? msg : "RFID: disabled (set rfid.host in config.json)";
    }

    function renderEvents(events) {
      const rows = (events || []).slice(-6).reverse();
      eventsBody.innerHTML = "";
      for (const ev of rows) {
        const tr = document.createElement("tr");
        const tdType = document.createElement("td");
        const tdTime = document.createElement("td");
        const tdInfo = document.createElement("td");

        tdType.textContent = ev.type || "-";
        tdTime.textContent = (ev.time_iso || "").replace("T", " ").replace("Z", "");

        if (ev.type === "rfid") {
          tdInfo.textContent = `${ev.tag || ""}${ev.approved ? " (approved)" : " (not approved)"}`;
        } else if (ev.type === "number") {
          tdInfo.textContent = `${ev.tag || ""} -> ${ev.number || ""} (attempt ${ev.attempt || 0})`;
        } else if (ev.type === "timeout") {
          tdInfo.textContent = `${ev.tag || ""} (timeout, attempt ${ev.attempt || 0})`;
        } else if (ev.type === "submitted") {
          const loc = ev.path ? `saved ${ev.path}` : "submitted";
          tdInfo.textContent = `${ev.tag || ""} -> ${ev.number || ""} ${loc}`;
        } else if (ev.type === "cooldown") {
          tdInfo.textContent = `${ev.tag || ""} cooling until ${ev.cooldown_until_iso || ""}`;
        } else if (ev.type === "blocked") {
          tdInfo.textContent = `${ev.tag || ""} blocked (${ev.reason || "awaiting submit"})`;
        } else if (ev.type === "mismatch") {
          tdInfo.textContent = `âš  ${ev.tag || ""} expected ${ev.expected_number || "-"} observed ${ev.observed_number || "-"} (att ${ev.attempt || 0})`;
          tdType.style.color = "var(--danger)";
          tdInfo.style.color = "var(--danger)";
        } else if (ev.type === "retry_requested") {
          tdInfo.textContent = `${ev.tag || ""} retry requested (attempt ${ev.attempt || "?"})`;
          tdType.style.color = "var(--muted)";
        } else if (ev.type === "tag_mismatch") {
          tdInfo.textContent = `âš  ${ev.tag || ""} expected ${ev.expected_number || "-"} observed ${ev.observed_number || "-"} (att ${ev.attempt || 0})`;
          tdType.style.color = "var(--danger)";
          tdInfo.style.color = "var(--danger)";
        } else if (ev.type === "tag_matched") {
          tdInfo.textContent = `${ev.tag || ""} matched ${ev.observed_number || "-"}`;
          tdType.style.color = "var(--ok)";
        } else if (ev.type === "multi_capture_processed") {
          tdInfo.textContent = `${ev.tag || ""} processed`;
        } else if (ev.type === "missing_label") {
          tdInfo.textContent = `âš  ${ev.tag || ""} has no label (att ${ev.attempt || 0})`;
          tdType.style.color = "var(--muted)";
        } else if (ev.type === "ocr_failed") {
          tdInfo.textContent = `${ev.tag || ""} OCR failed (att ${ev.attempt || 0})`;
        } else if (ev.type === "no_paper") {
          tdInfo.textContent = `${ev.tag || ""} no paper (att ${ev.attempt || 0})`;
        } else {
          tdInfo.textContent = ev.tag || "";
        }

        tr.appendChild(tdType);
        tr.appendChild(tdTime);
        tr.appendChild(tdInfo);
        eventsBody.appendChild(tr);
      }
      if (rows.length === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="3" style="color: var(--muted); border-top: 0;">No events yet.</td>';
        eventsBody.appendChild(tr);
      }
    }

    async function pollStatus() {
      if (pollInFlight) return;
      pollInFlight = true;
      try {
        const includeImages = activeTab === "capture";
        const data = await fetchJson("/api/status?include_images=" + (includeImages ? "1" : "0"));

        const r = data.rfid || {};
        const c = data.capture || {};
        const activeList = buildActiveTags(c);
        const group = c.group || data.group_session || {};

        approvedCount.textContent = `Approved tags: ${data.approved_tags_count || 0}`;

        if (!r.enabled) {
          setConn(false, false, "");
          listenBtn.disabled = true;
          if (listenEnabled) setListening(false);
        } else if (r.connected) {
          setConn(true, true, `RFID: connected (${r.host}:${r.port})`);
          listenBtn.disabled = false;
        } else {
          setConn(false, true, `RFID: disconnected (${r.host}:${r.port})`);
          listenBtn.disabled = false;
        }

        lastTag.textContent = r.last_tag || "-";
        lastApproved.textContent = r.last_tag ? (r.last_tag_approved ? "YES" : "NO") : "-";
        queueSize.textContent = String(r.queue_size ?? 0);

        capState.textContent = c.state || "idle";
        capTag.textContent = c.tag || "-";
        const attempt = Number(c.attempt ?? 0);
        const maxAttempts = Number(c.max_attempts ?? 0) || "-";
        capAttempt.textContent = `${attempt} / ${maxAttempts}`;
        capAttemptReset.textContent = c.attempt_reset_mode || "-";
        capSecondaryMode.textContent = c.secondary_snapshot_mode || "-";

        const expected = c.expected_number || "";
        const observed = c.observed_number || c.number || "";
        capExpected.textContent = expected || "-";
        capObserved.textContent = observed || "-";
        capMsg.textContent = c.message || "-";
        capNumber.textContent = observed ? observed : "-----";
        lastCaptureStatus = c;

        let matchStatus = "-";
        let bannerText = "Waiting for approved RFID tag...";
        let bannerClass = "muted";
        const secMsg = c.secondary_message || "";
        const state = c.state || "idle";
        const mismatch = !!c.mismatch;
        const mismatchReason = c.mismatch_reason || "";
        const mismatchMessage = c.mismatch_message || c.message || "";

        if (state === "matched" || (state === "awaiting_submit" && !mismatch && expected && observed && expected === observed)) {
          matchStatus = "MATCH";
          bannerText = "MATCH â€” numbers align";
          bannerClass = "ok";
        } else if (state === "mismatch" || mismatch) {
          matchStatus = "MISMATCH";
          bannerText = mismatchMessage || (expected ? `MISMATCH â€” Expected ${expected} but OCR read ${observed || "-"}` : "MISMATCH");
          bannerClass = "danger";
        } else if (state === "missing_label") {
          matchStatus = "MISSING LABEL";
          bannerText = "MISSING LABEL â€” This tag has no assigned 5-digit label";
          bannerClass = "warn";
        } else if (state === "no_paper") {
          matchStatus = "NO PAPER";
          bannerText = "NO PAPER â€” Paper not detected in this frame";
          bannerClass = "muted";
        } else if (state === "ocr_failed") {
          matchStatus = "OCR FAILED";
          bannerText = "OCR FAILED â€” No 5-digit number found";
          bannerClass = "warn";
        } else if (state === "failed") {
          matchStatus = "FAILED";
          bannerText = mismatchMessage || "Capture failed";
          bannerClass = "danger";
        } else if (state === "awaiting_submit") {
          matchStatus = "AWAITING SUBMIT";
          bannerText = "Captured digits. Submit required.";
          bannerClass = "ok";
        } else if (state === "running") {
          matchStatus = "CAPTURING";
          bannerText = "Capturing...";
          bannerClass = "muted";
        } else if (state === "submitted") {
          matchStatus = "SUBMITTED";
          bannerText = "Submitted. Ready for next tag.";
          bannerClass = "ok";
        }

        capMatch.textContent = matchStatus;
        capBanner.textContent = bannerText + (secMsg ? ` Secondary: ${secMsg}` : "");
        capBanner.className = `alert ${bannerClass}`;

        if (state === "running") capSub.textContent = "Capturing single frame...";
        else if (state === "awaiting_submit") capSub.textContent = "Captured digits. Submit required." + (secMsg ? ` Secondary: ${secMsg}` : "");
        else if (state === "submitted") capSub.textContent = "Submitted. Ready for next tag." + (secMsg ? ` Secondary: ${secMsg}` : "");
        else if (state === "success") capSub.textContent = "Done.";
        else if (state === "failed" || state === "mismatch" || state === "missing_label" || state === "ocr_failed" || state === "no_paper") capSub.textContent = mismatchMessage || c.message || "Failed.";
        else capSub.textContent = "Waiting for approved RFID tag...";

        const awaitingSubmit = !!c.awaiting_submit;
        const backendCanSubmit = typeof c.can_submit === "boolean" ? c.can_submit : null;
        const groupAllows = group && group.group_id ? !!group.matched : true;
        const allowSubmitRule = awaitingSubmit && !mismatch && (!!expected || backendCanSubmit === true) && groupAllows;
        const submitAllowed = backendCanSubmit !== null ? backendCanSubmit : allowSubmitRule;
        submitBtn.disabled = !submitAllowed;
        const disableForAttempts = (c.attempt_reset_mode === "per_tag_session") && c.max_attempts && (attempt >= c.max_attempts);
        let retryTag = c.tag || (activeList[0] && activeList[0].tag) || "";
        if (activeList.length) {
          const unresolved = activeList.find((t) => t.state && t.state !== "matched");
          if (unresolved) retryTag = unresolved.tag;
          const first = unresolved || activeList[0];
          if (first && first.max_attempts && first.attempt >= first.max_attempts && (c.attempt_reset_mode === "per_tag_session")) {
            retryBtn.disabled = true;
          }
        }
        const retryMaxAge = Number(c.retry_tag_max_age_seconds || 3);
        let recentSingle = false;
        if (retryTag) {
          const match = activeList.find((t) => t.tag === retryTag);
          if (match && match.last_seen && data.server_time) {
            recentSingle = (data.server_time - match.last_seen) <= retryMaxAge;
          } else if (r.last_tag_time && r.last_tag === retryTag && data.server_time) {
            recentSingle = (data.server_time - r.last_tag_time) <= retryMaxAge;
          }
        }
        let groupValid = false;
        if (data.group_session && data.group_session.group_id) {
          const seen = data.group_session.seen_tags || {};
          const window = Number(data.group_session.tag_window_seconds || 5);
          const nowTs = data.server_time || (Date.now() / 1000);
          const seenTags = Object.entries(seen).filter(([, ts]) => (nowTs - Number(ts || 0)) <= window);
          groupValid = seenTags.length > 0;
        }
        const retryEnabled = !!((recentSingle || groupValid) && state !== "running" && !disableForAttempts);
        retryBtn.disabled = !retryEnabled;

        const savedPath = c.submitted_path || "";
        const prefixHint = c.submitted_prefix ? `${c.submitted_prefix}.json` : "";
        if (submitAllowed && awaitingSubmit) {
          submitStatus.textContent = "Ready to submit captured data.";
        } else if (awaitingSubmit && !submitAllowed) {
          submitStatus.textContent = mismatchMessage || "Submit blocked (resolve mismatch/missing label)";
        } else if (c.state === "submitted" && (savedPath || prefixHint)) {
          submitStatus.textContent = `Saved: ${savedPath || prefixHint}`;
        } else {
          submitStatus.textContent = "Capture must succeed before submit.";
        }

        const cooldownUntil = Number(c.cooldown_until || 0);
        if (cooldownUntil && data.server_time) {
          const remaining = Math.max(0, Math.round(cooldownUntil - data.server_time));
          const mm = Math.floor(remaining / 60);
          const ss = String(remaining % 60).padStart(2, "0");
          submitStatus.textContent += ` | Tag cooldown ${mm}:${ss}`;
        }

        const captureTimeIso = c.number_time_iso || c.started_time_iso || "";
        const captureCaption = captureTimeIso ? `Captured at ${captureTimeIso}` : "";
        const attemptCaption = attempt ? `Attempt ${attempt}` : "";

        if (includeImages) {
          imgOriginal.src = c.original_b64 ? "data:image/jpeg;base64," + c.original_b64 : "";
          imgPaper.src = c.paper_b64 ? "data:image/jpeg;base64," + c.paper_b64 : "";
          imgSecondary.src = c.secondary_b64 ? "data:image/jpeg;base64," + c.secondary_b64 : "";
          titleOriginal.textContent = "Original" + (attemptCaption ? ` â€¢ ${attemptCaption}` : "");
          titlePaper.textContent = "Warped paper" + (captureCaption ? ` â€¢ ${captureCaption}` : "");
          titleSecondary.textContent = "Secondary camera" + (c.secondary_message ? ` â€¢ ${c.secondary_message}` : "");
        } else {
          imgOriginal.src = "";
          imgPaper.src = "";
          imgSecondary.src = "";
          titleOriginal.textContent = "Original (outline)";
          titlePaper.textContent = "Warped paper";
          titleSecondary.textContent = "Secondary camera";
        }

        // Active tags table
        activeTagsBody.innerHTML = "";
        const actToRender = activeList.length ? activeList : [];
        for (const item of actToRender) {
          const tr = document.createElement("tr");
          const tdTag = document.createElement("td");
          const tdExp = document.createElement("td");
          const tdObs = document.createElement("td");
          const tdState = document.createElement("td");
          const tdAtt = document.createElement("td");
          tdTag.textContent = item.tag || "-";
          tdExp.textContent = item.expected_number || "-";
          tdObs.textContent = item.observed_number || "-";
          const badge = document.createElement("span");
          badge.className = "badge muted";
          const st = (item.state || "").toLowerCase();
          if (st === "matched") badge.className = "badge ok";
          else if (st === "mismatch") badge.className = "badge danger";
          else if (st === "missing_label") badge.className = "badge warn";
          else badge.className = "badge muted";
          badge.textContent = st || "-";
          tdState.appendChild(badge);
          tdAtt.textContent = `${item.attempt || 0} / ${item.max_attempts || "-"}`;
          tr.append(tdTag, tdExp, tdObs, tdState, tdAtt);
          activeTagsBody.appendChild(tr);
        }
        if (actToRender.length === 0) {
          activeTagsBody.innerHTML = '<tr><td colspan="5" style="color: var(--muted);">No active tags.</td></tr>';
        }

        // Mismatch list (group-aware)
        const mismatches = (c.mismatches && c.mismatches.length ? c.mismatches : activeList.filter((i) => i.mismatch || ["mismatch", "missing_label", "ocr_failed", "no_paper", "failed"].includes((i.state || "").toLowerCase())) ) || [];
        const groupMismatches = [];
        if (group && group.matched === false) {
          if ((group.missing_tags || []).length) {
            groupMismatches.push(...group.missing_tags.map((t) => ({ tag: t, reason: "missing_tag" })));
          }
          if ((group.extra_tags || []).length) {
            groupMismatches.push(...group.extra_tags.map((t) => ({ tag: t, reason: "extra_tag" })));
          }
          if ((group.missing_labels || []).length) {
            groupMismatches.push(...group.missing_labels.map((l) => ({ label: l, reason: "missing_label" })));
          }
          if ((group.extra_labels || []).length) {
            groupMismatches.push(...group.extra_labels.map((l) => ({ label: l, reason: "extra_label" })));
          }
        }
        const combinedMismatches = mismatches.length ? mismatches : [];
        if (groupMismatches.length) combinedMismatches.push(...groupMismatches);
        if (!combinedMismatches.length) {
          mismatchList.textContent = "No mismatches.";
        } else {
          mismatchList.innerHTML = "";
          for (const m of combinedMismatches) {
            const div = document.createElement("div");
            const reason = (m.reason || m.state || "").replace("_", " ").toUpperCase();
            const exp = m.expected_number ? ` Expected ${m.expected_number}` : m.label ? ` Label ${m.label}` : "";
            const obs = m.observed_number ? `, Observed ${m.observed_number}` : "";
            div.textContent = `${m.tag || m.label || "-"} â€” ${reason}${exp}${obs}`;
            mismatchList.appendChild(div);
          }
        }

        // Group display
        if (group && group.group_id) {
          groupStatus.textContent = `Group ${group.group_id} ${group.name ? "(" + group.name + ")" : ""} â€” ${group.message || ""}`;
          const badgeClass = group.matched ? "ok" : "danger";
          capBanner.className = `alert ${badgeClass}`;
          capBanner.textContent = group.matched ? "GROUP MATCHED" : group.message || "GROUP MISMATCH";
          groupSetsSummary.innerHTML = `Required tags (${(group.required_tags || []).length}): ${(group.required_tags || []).join(", ") || "-"}<br/>Seen tags (${(group.seen_tags || []).length}): ${(group.seen_tags || []).join(", ") || "-"}<br/>Required labels (${(group.required_labels || []).length}): ${(group.required_labels || []).join(", ") || "-"}<br/>OCR labels (${(group.ocr_labels || []).length}): ${(group.ocr_labels || []).join(", ") || "-"}`;
          if (groupSelect && group.group_id !== groupSelect.value) {
            groupSelect.value = group.group_id;
          }
        } else {
          groupStatus.textContent = "No active group.";
          groupSetsSummary.textContent = "";
        }

        renderEvents(data.events || []);

        if (activeTab === "tags" && listenEnabled && r.enabled) {
          const tag = (r.last_tag || "").trim();
          const tagTime = Number(r.last_tag_time || 0);
          const tagApproved = !!r.last_tag_approved;
          const nowTs = Date.now() / 1000;

          const isNewer = tag && tagTime && tagTime > lastScannedTime;
          const debounceOk = !lastListenedTag || tag !== lastListenedTag || (nowTs - lastListenTs) > LISTEN_DEBOUNCE_SECONDS;
          if (tag && isNewer && debounceOk) {
            lastScannedTime = tagTime;
            lastListenedTag = tag;
            lastListenTs = nowTs;

            tagInput.value = tag;
            if (!tagLabelInput.value.trim()) {
              tagLabelInput.value = "";
            }
            tagsStatus.textContent = tagApproved ? `Tag detected (approved): ${tag}` : `Tag detected: ${tag}. Review and click Add Tag to save.`;
          }
        }
      } catch (e) {
        connDot.classList.remove("ok");
        connText.textContent = "Server: not reachable";
        listenBtn.disabled = true;
      } finally {
        pollInFlight = false;
      }
    }

    setListening(false);
    refreshTags();
    pollStatus();
    clearGroupEditor();
    loadGroups();
    setInterval(pollStatus, 1000);
  </script>
</body>
</html>

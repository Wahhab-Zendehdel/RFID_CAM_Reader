<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RFID Label OCR</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #111825;
      --panel2: #0e1622;
      --text: #f5f7fa;
      --muted: #9aa4b2;
      --accent: #2d8cff;
      --danger: #ff4d4d;
      --ok: #22c55e;
      --amber: #f59e0b;
      --border: rgba(255, 255, 255, 0.08);
      --app-header-h: 56px;
      --page-padding: 28px;
      --content-padding: 24px;
      --panel-gap: 8px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden; /* fixed layout, no page scroll */
    }

    .app {
      height: 100vh;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .topbar {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .brand {
      font-weight: 800;
      letter-spacing: 0.2px;
      white-space: nowrap;
    }

    .tabs {
      display: flex;
      gap: 6px;
      padding: 4px;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 12px;
    }

    .tab-btn {
      appearance: none;
      border: 0;
      background: transparent;
      color: var(--muted);
      padding: 10px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: background 120ms ease;
    }

    .tab-btn.active {
      background: rgba(45, 140, 255, 0.18);
      color: var(--text);
    }

    .conn {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 13px;
      white-space: nowrap;
    }

    .dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: var(--danger);
    }

    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--amber); }

    .content {
      flex: 1 1 auto;
      min-height: 0;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      overflow: hidden;
    }

    .tab-panel {
      height: 100%;
      display: none;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .tab-panel.active {
      display: flex;
    }

    .rfid-capture-layout {
      flex: 1 1 auto;
      min-height: 0;
      min-width: 0;
      width: 100%;
      height: calc(100vh - var(--app-header-h) - var(--page-padding) - var(--content-padding));
      height: calc(100dvh - var(--app-header-h) - var(--page-padding) - var(--content-padding));
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      min-height: 0;
      min-width: 0;
      overflow: hidden;
    }

    .panel-col {
      display: flex;
      flex-direction: column;
      min-height: 0;
      min-width: 0;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="text"] {
      flex: 1 1 auto;
      min-width: 160px;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      outline: none;
      font-size: 14px;
    }

    button.primary {
      border: 0;
      padding: 12px 14px;
      border-radius: 12px;
      background: var(--accent);
      color: white;
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
    }

    button.primary:disabled {
      opacity: 0.55;
      cursor: default;
    }

    button.secondary {
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
    }

    button.secondary.on {
      border-color: rgba(34, 197, 94, 0.6);
      background: rgba(34, 197, 94, 0.18);
    }

    button.secondary:disabled {
      opacity: 0.55;
      cursor: default;
    }

    .hint {
      color: var(--muted);
      font-size: 13px;
    }

    .status {
      min-height: 18px;
      color: var(--muted);
      font-size: 13px;
    }


    .tag-grid {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-wrap: wrap;
      align-content: flex-start;
      gap: 8px;
      overflow: hidden; /* no internal scroll; we cap render count */
    }

    .chip {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }

    .chip button {
      border: 0;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      height: 22px;
      border-radius: 999px;
      cursor: pointer;
      line-height: 22px;
      padding: 0 8px;
      font-size: 11px;
    }

    .capture-grid {
      flex: 1 1 auto;
      min-height: 0;
      display: grid;
      grid-template-columns: var(--capture-left-width, 34%) var(--capture-right-width, 66%);
      gap: var(--capture-gap, 12px);
      min-width: 0;
      height: 100%;
    }

    .capture-col {
      display: grid;
      gap: var(--capture-gap, 12px);
      min-height: 0;
      min-width: 0;
    }

    .capture-col.capture-left {
      grid-template-rows: minmax(0, var(--capture-left-top, 2.2fr)) minmax(0, var(--capture-left-bottom, 0.9fr));
    }

    .capture-col.capture-right {
      grid-template-rows: minmax(0, var(--capture-right-top, 2.2fr)) minmax(0, var(--capture-right-bottom, 0.9fr));
    }

    .capture-col > .panel {
      min-height: 0;
      min-width: 0;
    }

    .kv {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 4px 8px;
      font-size: 13px;
    }

    .kv .k { color: var(--muted); }
    .kv .v {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .number {
      margin-top: 6px;
      text-align: center;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.22);
      font-size: clamp(22px, 2.6vw, 46px);
      font-weight: 900;
      letter-spacing: 2px;
    }

    .images {
      min-height: 0;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-auto-rows: minmax(0, 1fr);
      gap: 12px;
    }

    .image-box {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
      min-width: 0;
    }

    .image-title {
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .imgwrap {
      flex: 1 1 auto;
      min-height: 0;
      min-width: 0;
      border-radius: 12px;
      border: 1px dashed var(--border);
      background: rgba(0, 0, 0, 0.18);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      table-layout: fixed;
    }

    th, td {
      text-align: left;
      padding: 8px 8px;
      border-top: 1px solid var(--border);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    th {
      color: var(--muted);
      font-weight: 700;
      border-top: 0;
    }

    .events-scroll {
      flex: 1 1 auto;
      min-height: 0;
      min-width: 0;
      overflow: auto;
      border-radius: 10px;
      scrollbar-gutter: stable;
      padding-inline-end: 6px;
    }

    .warning-box {
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.2);
      min-height: 70px;
      color: var(--muted);
      font-size: 13px;
      white-space: pre-wrap;
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
      scrollbar-gutter: stable;
      padding-inline-end: 6px;
    }

    .warning-box.warn {
      border-color: rgba(255, 77, 77, 0.6);
      background: rgba(255, 77, 77, 0.14);
      color: #ffd2d2;
    }

    .indicator-grid {
      display: flex;
      flex-wrap: nowrap;
      gap: 12px;
      margin-top: 8px;
      font-size: 12px;
      min-width: 0;
      overflow: hidden;
    }

    .indicator-row {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
      white-space: nowrap;
    }

    .indicator-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.12);
      border: 1px solid var(--border);
      flex: 0 0 auto;
    }

    .indicator-dot.on {
      background: var(--ok);
      border-color: rgba(34, 197, 94, 0.5);
    }

    .indicator-dot.warn {
      background: var(--danger);
      border-color: rgba(255, 77, 77, 0.6);
    }

    .indicator-dot.amber {
      background: var(--amber);
      border-color: rgba(245, 158, 11, 0.6);
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .toggle input {
      width: 16px;
      height: 16px;
    }

    .panel-info { overflow: hidden; }
    .panel-images { overflow: hidden; }
    .panel-events { overflow: hidden; }
    .panel-warnings { overflow: hidden; gap: 10px; }
    .panel-images .images { flex: 1 1 auto; min-height: 0; }
    .panel-heading { margin-bottom: var(--panel-gap); }
    .panel-section { margin-top: var(--panel-gap); }
    .panel-actions { margin-top: 6px; }

    @media (max-width: 1200px) {
      .capture-grid {
        grid-template-columns: var(--capture-left-width-tablet, 40%) var(--capture-right-width-tablet, 60%);
        gap: 10px;
      }
      .capture-col { gap: 10px; }
      .images {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        grid-auto-rows: minmax(150px, 1fr);
        gap: 10px;
      }
    }

    @media (max-width: 980px) {
      body { overflow: auto; }
      .rfid-capture-layout { height: auto; }
      .capture-grid {
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
        gap: 10px;
      }
      .capture-col {
        display: contents;
      }
      .panel-images { grid-row: 1; }
      .panel-info { grid-row: 2; }
      .panel-warnings { grid-row: 3; }
      .panel-events { grid-row: 4; }
      .images {
        grid-template-columns: 1fr;
        grid-auto-rows: minmax(180px, 1fr);
      }
      .kv { grid-template-columns: 120px 1fr; }
      .indicator-grid { flex-wrap: wrap; }
    }
  </style>
</head>
<body
  data-target-digits="{{ target_digits|default(5) }}"
  data-poll-interval="{{ poll_interval_ms|default(1000) }}"
  data-beep-default="{{ '1' if beep_default else '0' }}"
  data-require-label-match="{{ '1' if require_label_match else '0' }}"
  data-present-window="{{ present_window_seconds|default(2.0) }}"
>
  <div class="app">
    <header class="topbar">
      <div class="brand">RFID Label OCR</div>

      <nav class="tabs" aria-label="Tabs">
        <button class="tab-btn active" data-tab="tags" type="button">Approved Tags</button>
        <button class="tab-btn" data-tab="capture" type="button">RFID Capture</button>
      </nav>

      <div class="conn" id="conn">
        <span class="dot" id="conn-dot"></span>
        <span id="conn-text">RFID: ...</span>
      </div>
    </header>

    <main class="content">
      <section class="tab-panel active" id="tab-tags">
        <div class="panel">
          <div class="row">
            <input id="tag-input" type="text" placeholder="Enter EPC/UID (hex) ..." autocomplete="off" />
            <input id="label-input" type="text" placeholder="Label number" autocomplete="off" inputmode="numeric" />
            <button class="primary" id="add-tag-btn" type="button">Add Tag</button>
            <button class="secondary" id="listen-btn" type="button">Listening: OFF</button>
          </div>
          <div class="status" id="tags-status"></div>
          <div class="hint" id="tags-meta">Approved tags: 0</div>
        </div>

        <div class="panel" style="flex: 1 1 auto; min-height: 0;">
          <div class="hint" style="margin-bottom: 10px;">Approved tag list (stored in <code>approved_tags.json</code>)</div>
          <div class="tag-grid" id="tags"></div>
        </div>
      </section>

      <section class="tab-panel" id="tab-capture">
        <div class="rfid-capture-layout">
          <div class="capture-grid">
          <div class="capture-col capture-left">
            <div class="panel panel-col panel-info">
              <div class="hint panel-heading" id="approved-count">Approved tags: 0</div>
              <div class="kv panel-section">
                <div class="k">Last RFID tag</div><div class="v" id="last-tag">-</div>
                <div class="k">Approved</div><div class="v" id="last-approved">-</div>
                <div class="k">Queue</div><div class="v" id="queue-size">0</div>
                <div class="k">Capture</div><div class="v" id="cap-state">idle</div>
                <div class="k">Trigger tag</div><div class="v" id="cap-tag">-</div>
                <div class="k">Effective tag</div><div class="v" id="cap-effective">-</div>
                <div class="k">Expected label</div><div class="v" id="cap-expected">-</div>
                <div class="k">Detected label</div><div class="v" id="cap-detected">-</div>
                <div class="k">Attempt</div><div class="v" id="cap-attempt">0</div>
                <div class="k">Message</div><div class="v" id="cap-msg">-</div>
              </div>

              <div class="number" id="cap-number">-----</div>
              <div class="status" id="cap-sub">Waiting for approved RFID tag...</div>
              <div class="row panel-actions">
                <button class="primary" id="submit-btn" type="button" disabled>Submit capture</button>
                <div class="hint" id="submit-status">Capture must succeed before submit.</div>
              </div>
            </div>

            <div class="panel panel-col panel-events">
              <div class="hint panel-heading">Recent events</div>
              <div class="events-scroll">
                <table>
                  <thead>
                    <tr>
                      <th style="width: 90px;">Type</th>
                      <th style="width: 120px;">Time (UTC)</th>
                      <th>Tag / Info</th>
                    </tr>
                  </thead>
                  <tbody id="events"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="capture-col capture-right">
            <div class="panel panel-col panel-images">
              <div class="hint panel-heading">Capture images</div>
              <div class="images">
                <div class="image-box">
                  <div class="image-title">Original (outline)</div>
                  <div class="imgwrap"><img id="img-original" alt="Original frame" /></div>
                </div>
                <div class="image-box">
                  <div class="image-title">Warped paper</div>
                  <div class="imgwrap"><img id="img-paper" alt="Warped paper" /></div>
                </div>
                <div class="image-box">
                  <div class="image-title">Secondary camera</div>
                  <div class="imgwrap"><img id="img-secondary" alt="Secondary camera frame" /></div>
                </div>
              </div>
            </div>

            <div class="panel panel-col panel-warnings">
              <div class="hint panel-heading">Warnings & indicators</div>
              <div class="warning-box" id="cap-warning">No warnings.</div>
              <div class="indicator-grid">
                <div class="indicator-row"><span class="indicator-dot" id="ind-rfid"></span><span title="RFID connection">RFID</span></div>
                <div class="indicator-row"><span class="indicator-dot" id="ind-cam-primary"></span><span title="Primary camera">Cam 1</span></div>
                <div class="indicator-row"><span class="indicator-dot" id="ind-cam-secondary"></span><span title="Secondary camera">Cam 2</span></div>
                <div class="indicator-row"><span class="indicator-dot" id="ind-tag"></span><span title="Tag detected">Tag</span></div>
                <div class="indicator-row"><span class="indicator-dot" id="ind-label"></span><span title="Label detected">Label</span></div>
                <div class="indicator-row"><span class="indicator-dot" id="ind-match"></span><span title="Label match">Match</span></div>
              </div>
              <label class="toggle">
                <input type="checkbox" id="beep-toggle" />
                Beep on detection
              </label>
            </div>
          </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    const tabButtons = Array.from(document.querySelectorAll(".tab-btn"));
    const tabPanels = {
      tags: document.getElementById("tab-tags"),
      capture: document.getElementById("tab-capture"),
    };

    const connDot = document.getElementById("conn-dot");
    const connText = document.getElementById("conn-text");

    const tagInput = document.getElementById("tag-input");
    const labelInput = document.getElementById("label-input");
    const addTagBtn = document.getElementById("add-tag-btn");
    const listenBtn = document.getElementById("listen-btn");
    const tagsStatus = document.getElementById("tags-status");
    const tagsMeta = document.getElementById("tags-meta");
    const tagsContainer = document.getElementById("tags");

    const approvedCount = document.getElementById("approved-count");
    const lastTag = document.getElementById("last-tag");
    const lastApproved = document.getElementById("last-approved");
    const queueSize = document.getElementById("queue-size");
    const capState = document.getElementById("cap-state");
    const capTag = document.getElementById("cap-tag");
    const capEffective = document.getElementById("cap-effective");
    const capExpected = document.getElementById("cap-expected");
    const capDetected = document.getElementById("cap-detected");
    const capAttempt = document.getElementById("cap-attempt");
    const capMsg = document.getElementById("cap-msg");
    const capNumber = document.getElementById("cap-number");
    const capSub = document.getElementById("cap-sub");
    const capWarning = document.getElementById("cap-warning");
    const submitBtn = document.getElementById("submit-btn");
    const submitStatus = document.getElementById("submit-status");
    const imgOriginal = document.getElementById("img-original");
    const imgPaper = document.getElementById("img-paper");
    const imgSecondary = document.getElementById("img-secondary");
    const eventsBody = document.getElementById("events");
    const indRfid = document.getElementById("ind-rfid");
    const indCamPrimary = document.getElementById("ind-cam-primary");
    const indCamSecondary = document.getElementById("ind-cam-secondary");
    const indTag = document.getElementById("ind-tag");
    const indLabel = document.getElementById("ind-label");
    const indMatch = document.getElementById("ind-match");
    const beepToggle = document.getElementById("beep-toggle");

    const rawTargetDigits = Number(document.body.dataset.targetDigits || 5);
    let targetDigits = Number.isFinite(rawTargetDigits) && rawTargetDigits > 0 ? rawTargetDigits : null;
    const pollIntervalMs = Number(document.body.dataset.pollInterval || 1000);
    const safePollIntervalMs = Number.isFinite(pollIntervalMs) && pollIntervalMs > 200 ? pollIntervalMs : 1000;
    const requireLabelMatch = document.body.dataset.requireLabelMatch === "1";
    const presentWindowSeconds = Number(document.body.dataset.presentWindow || 2);
    const safePresentWindowSeconds = Number.isFinite(presentWindowSeconds) && presentWindowSeconds > 0 ? presentWindowSeconds : 2;
    const beepDefault = document.body.dataset.beepDefault === "1";
    const tagsCache = new Map();

    let activeTab = "tags";
    let pollInFlight = false;
    let listenEnabled = false;
    let lastScannedTime = Date.now() / 1000;
    let lastBeepTagTime = 0;
    let lastBeepLabelTime = 0;
    let latestTagTime = 0;
    let latestNumberTime = 0;
    let beepEnabled = beepDefault;

    function applyTargetDigits(value) {
      const digits = Number.isFinite(value) && value > 0 ? value : null;
      targetDigits = digits;
      if (labelInput) {
        labelInput.placeholder = digits ? `Label number (${digits} digits)` : "Label number";
        labelInput.maxLength = digits ? digits : 24;
      }
    }

    applyTargetDigits(targetDigits);
    if (beepToggle) {
      beepToggle.checked = beepEnabled;
    }

    function setActiveTab(name) {
      activeTab = name;
      tabButtons.forEach((b) => b.classList.toggle("active", b.dataset.tab === name));
      Object.entries(tabPanels).forEach(([key, el]) => el.classList.toggle("active", key === name));
      if (name !== "tags") setListening(false);
    }

    function updateCaptureLayoutVars() {
      const appEl = document.querySelector(".app");
      const topbarEl = document.querySelector(".topbar");
      const contentEl = document.querySelector(".content");
      if (!appEl || !topbarEl || !contentEl) return;

      const appStyles = getComputedStyle(appEl);
      const contentStyles = getComputedStyle(contentEl);
      const appPadY = parseFloat(appStyles.paddingTop) + parseFloat(appStyles.paddingBottom);
      const appGap = parseFloat(appStyles.rowGap || appStyles.gap || 0);
      const contentPadY = parseFloat(contentStyles.paddingTop) + parseFloat(contentStyles.paddingBottom);

      document.documentElement.style.setProperty("--app-header-h", `${topbarEl.offsetHeight}px`);
      document.documentElement.style.setProperty("--page-padding", `${appPadY + appGap}px`);
      document.documentElement.style.setProperty("--content-padding", `${contentPadY}px`);
    }

    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
    });

    updateCaptureLayoutVars();
    window.addEventListener("resize", updateCaptureLayoutVars);

    function setListening(enabled) {
      listenEnabled = !!enabled;
      listenBtn.classList.toggle("on", listenEnabled);
      listenBtn.textContent = listenEnabled ? "Listening: ON" : "Listening: OFF";
      lastScannedTime = listenEnabled ? Date.now() / 1000 : 0;
      if (listenEnabled) {
        tagsStatus.textContent = "Listening... present a tag to the reader.";
      }
    }

    listenBtn.addEventListener("click", () => {
      setListening(!listenEnabled);
    });

    if (beepToggle) {
      beepToggle.addEventListener("change", () => {
        beepEnabled = beepToggle.checked;
        if (beepEnabled) {
          lastBeepTagTime = latestTagTime || lastBeepTagTime;
          lastBeepLabelTime = latestNumberTime || lastBeepLabelTime;
          ensureAudioContext();
        }
      });
    }

    async function fetchJson(url, options) {
      const resp = await fetch(url, options);
      const data = await resp.json().catch(() => null);
      if (!resp.ok) {
        const msg = data && data.message ? data.message : resp.statusText;
        throw new Error(msg);
      }
      return data;
    }

    let audioContext = null;

    function ensureAudioContext() {
      if (!audioContext) {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) return null;
        audioContext = new AudioCtx();
      }
      if (audioContext.state === "suspended") {
        audioContext.resume().catch(() => {});
      }
      return audioContext;
    }

    function playBeep(frequency, durationMs) {
      if (!beepEnabled) return;
      const ctx = ensureAudioContext();
      if (!ctx) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.frequency.value = frequency || 880;
      osc.type = "sine";
      gain.gain.value = 0.08;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + (durationMs || 0.08));
    }

    function validateLabelInput(label) {
      const trimmed = (label || "").trim();
      if (!trimmed) return { ok: true, value: "" };
      if (!/^\d+$/.test(trimmed)) {
        return { ok: false, message: "Label must contain digits only." };
      }
      if (targetDigits && trimmed.length !== targetDigits) {
        return { ok: false, message: `Label must be ${targetDigits} digits.` };
      }
      return { ok: true, value: trimmed };
    }

    function renderTags(items) {
      const MAX_RENDER = 50;
      const safeItems = Array.isArray(items) ? items : [];
      const shown = safeItems.slice(0, MAX_RENDER);
      tagsContainer.innerHTML = "";
      tagsCache.clear();

      for (const item of safeItems) {
        const tag = String(item.tag || "");
        if (!tag) continue;
        tagsCache.set(tag, String(item.label || ""));
      }

      for (const item of shown) {
        const tag = String(item.tag || "");
        if (!tag) continue;
        const label = String(item.label || "");
        const chip = document.createElement("div");
        chip.className = "chip";

        const text = document.createElement("span");
        const labelText = label ? label : "(no label)";
        text.textContent = `${tag} - ${labelText}`;

        const edit = document.createElement("button");
        edit.type = "button";
        edit.textContent = "edit";
        edit.title = "Edit label";
        edit.addEventListener("click", async () => {
          const promptLabel = targetDigits ? `Enter ${targetDigits}-digit label for ${tag}` : `Enter label for ${tag}`;
          const nextLabel = window.prompt(promptLabel, label);
          if (nextLabel === null) return;
          const validation = validateLabelInput(nextLabel);
          if (!validation.ok) {
            tagsStatus.textContent = validation.message;
            return;
          }
          tagsStatus.textContent = "";
          try {
            await fetchJson("/api/tags", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ tag, label: validation.value }),
            });
            await refreshTags();
          } catch (e) {
            tagsStatus.textContent = String(e.message || e);
          }
        });

        const del = document.createElement("button");
        del.type = "button";
        del.textContent = "x";
        del.title = "Remove";
        del.addEventListener("click", async () => {
          try {
            await fetchJson("/api/tags/" + encodeURIComponent(tag), { method: "DELETE" });
            await refreshTags();
          } catch (e) {
            tagsStatus.textContent = String(e.message || e);
          }
        });

        chip.appendChild(text);
        chip.appendChild(edit);
        chip.appendChild(del);
        tagsContainer.appendChild(chip);
      }

      const extra = safeItems.length > MAX_RENDER ? ` (showing ${MAX_RENDER} of ${safeItems.length})` : "";
      tagsMeta.textContent = `Approved tags: ${safeItems.length}${extra}`;
    }

    async function refreshTags() {
      try {
        const data = await fetchJson("/api/tags");
        if (Number.isFinite(Number(data.target_digits))) {
          applyTargetDigits(Number(data.target_digits));
        }
        if (Array.isArray(data.items)) {
          renderTags(data.items);
        } else if (Array.isArray(data.tags)) {
          renderTags(data.tags.map((tag) => ({ tag, label: "" })));
        } else {
          renderTags([]);
        }
      } catch (e) {
        tagsStatus.textContent = String(e.message || e);
      }
    }

    async function addTag() {
      const tag = tagInput.value.trim();
      if (!tag) return;
      const labelRaw = labelInput ? labelInput.value.trim() : "";
      const validation = validateLabelInput(labelRaw);
      if (!validation.ok) {
        tagsStatus.textContent = validation.message;
        return;
      }
      addTagBtn.disabled = true;
      tagsStatus.textContent = "";
      try {
        const payload = { tag };
        if (validation.value) {
          payload.label = validation.value;
        }
        await fetchJson("/api/tags", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        tagInput.value = "";
        if (labelInput) labelInput.value = "";
        await refreshTags();
      } catch (e) {
        tagsStatus.textContent = String(e.message || e);
      } finally {
        addTagBtn.disabled = false;
      }
    }

    addTagBtn.addEventListener("click", addTag);
    tagInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") addTag();
    });
    if (labelInput) {
      labelInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") addTag();
      });
    }

    async function submitCapture() {
      submitBtn.disabled = true;
      submitStatus.textContent = "Submitting...";
      try {
        const resp = await fetchJson("/api/capture/submit", { method: "POST" });
        const saved = resp.saved || {};
        const files = saved.files || {};
        const path = files.json || "";
        const prefix = saved.prefix || "";
        if (path) submitStatus.textContent = `Saved: ${path}`;
        else if (prefix) submitStatus.textContent = `Submitted (${prefix})`;
        else submitStatus.textContent = "Submitted.";
      } catch (e) {
        submitStatus.textContent = `Submit failed: ${String(e.message || e)}`;
      } finally {
        // button state is refreshed by pollStatus
      }
    }

    submitBtn.addEventListener("click", submitCapture);

    function setConn(state, enabled, msg) {
      connDot.classList.toggle("ok", state === "on");
      connDot.classList.toggle("warn", state === "amber");
      connText.textContent = enabled ? msg : "RFID: disabled (set rfid.host in config.json)";
    }

    function renderEvents(events) {
      const rows = (events || []).slice(-6).reverse();
      eventsBody.innerHTML = "";
      for (const ev of rows) {
        const tr = document.createElement("tr");
        const tdType = document.createElement("td");
        const tdTime = document.createElement("td");
        const tdInfo = document.createElement("td");

        tdType.textContent = ev.type || "-";
        tdTime.textContent = (ev.time_iso || "").replace("T", " ").replace("Z", "");

        if (ev.type === "rfid") {
          tdInfo.textContent = `${ev.tag || ""}${ev.approved ? " (approved)" : " (not approved)"}`;
        } else if (ev.type === "number") {
          tdInfo.textContent = `${ev.tag || ""} -> ${ev.number || ""} (attempt ${ev.attempt || 0})`;
        } else if (ev.type === "mismatch") {
          tdInfo.textContent = `${ev.tag || ""} expected ${ev.expected || ""} detected ${ev.detected || ""}`;
        } else if (ev.type === "resolved") {
          tdInfo.textContent = `${ev.tag || ""} -> ${ev.resolved_tag || ""} (${ev.detected_label || ""})`;
        } else if (ev.type === "timeout") {
          tdInfo.textContent = `${ev.tag || ""} (timeout, attempt ${ev.attempt || 0})`;
        } else if (ev.type === "rfid_connected") {
          tdInfo.textContent = `connected ${ev.host || ""}:${ev.port || ""}`.trim();
        } else if (ev.type === "rfid_disconnected") {
          tdInfo.textContent = `disconnected${ev.error ? `: ${ev.error}` : ""}`;
        } else if (ev.type === "rfid_reconnecting") {
          tdInfo.textContent = `reconnecting${ev.error ? `: ${ev.error}` : ""}`;
        } else if (ev.type === "camera_primary_connected") {
          tdInfo.textContent = `camera 1 connected${ev.source ? ` (${ev.source})` : ""}`;
        } else if (ev.type === "camera_primary_lost") {
          tdInfo.textContent = `camera 1 lost${ev.error ? `: ${ev.error}` : ""}`;
        } else if (ev.type === "camera_primary_reconnecting") {
          tdInfo.textContent = `camera 1 reconnecting${ev.error ? `: ${ev.error}` : ""}`;
        } else if (ev.type === "camera_secondary_connected") {
          tdInfo.textContent = `camera 2 connected${ev.source ? ` (${ev.source})` : ""}`;
        } else if (ev.type === "camera_secondary_lost") {
          tdInfo.textContent = `camera 2 lost${ev.error ? `: ${ev.error}` : ""}`;
        } else if (ev.type === "camera_secondary_reconnecting") {
          tdInfo.textContent = `camera 2 reconnecting${ev.error ? `: ${ev.error}` : ""}`;
        } else if (ev.type === "submitted") {
          const loc = ev.path ? `saved ${ev.path}` : "submitted";
          const original = ev.tag_original ? ` (was ${ev.tag_original})` : "";
          const labelInfo = ev.label_detected ? ` label ${ev.label_detected}` : "";
          const matchInfo = ev.label_match === false ? " (mismatch)" : "";
          tdInfo.textContent = `${ev.tag || ""}${original} -> ${ev.number || ""}${labelInfo}${matchInfo} ${loc}`;
        } else if (ev.type === "cooldown") {
          tdInfo.textContent = `${ev.tag || ""} cooling until ${ev.cooldown_until_iso || ""}`;
        } else if (ev.type === "blocked") {
          tdInfo.textContent = `${ev.tag || ""} blocked (${ev.reason || "awaiting submit"})`;
        } else {
          tdInfo.textContent = ev.tag || "";
        }

        tr.appendChild(tdType);
        tr.appendChild(tdTime);
        tr.appendChild(tdInfo);
        eventsBody.appendChild(tr);
      }
      if (rows.length === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = '<td colspan="3" style="color: var(--muted); border-top: 0;">No events yet.</td>';
        eventsBody.appendChild(tr);
      }
    }

    function setIndicator(el, state) {
      if (!el) return;
      el.classList.toggle("on", state === "on");
      el.classList.toggle("warn", state === "warn");
      el.classList.toggle("amber", state === "amber");
    }

    function resolveConnState(status) {
      if (!status || status.enabled === false) return "off";
      if (status.reconnecting || status.stale) return "amber";
      if (status.connected) return "on";
      return "warn";
    }

    function buildConnWarning(label, status) {
      if (!status) return "";
      const err = status.last_error ? `: ${status.last_error}` : "";
      if (status.enabled === false) return err ? `${label} disabled${err}` : "";
      if (status.reconnecting) return `${label} reconnecting${err}`;
      if (!status.connected) return `${label} disconnected${err}`;
      if (status.stale) return `${label} stale${err}`;
      return "";
    }

    async function pollStatus() {
      if (pollInFlight) return;
      pollInFlight = true;
      try {
        const includeImages = activeTab === "capture";
        const data = await fetchJson("/api/status?include_images=" + (includeImages ? "1" : "0"));

        const r = data.rfid || {};
        const c = data.capture || {};
        const cams = data.cameras || {};
        const camPrimary = cams.primary || {};
        const camSecondary = cams.secondary || data.secondary_camera || {};

        approvedCount.textContent = `Approved tags: ${data.approved_tags_count || 0}`;

        if (!r.enabled) {
          setConn("off", false, "");
          listenBtn.disabled = true;
          if (listenEnabled) setListening(false);
        } else {
          const rfidState = resolveConnState(r);
          if (rfidState === "on") {
            setConn("on", true, `RFID: connected (${r.host}:${r.port})`);
          } else if (rfidState === "amber") {
            const label = r.stale ? "stale" : "reconnecting";
            setConn("amber", true, `RFID: ${label} (${r.host}:${r.port})`);
          } else {
            setConn("warn", true, `RFID: disconnected (${r.host}:${r.port})`);
          }
          listenBtn.disabled = false;
        }

        lastTag.textContent = r.last_tag || "-";
        lastApproved.textContent = r.last_tag ? (r.last_tag_approved ? "YES" : "NO") : "-";
        queueSize.textContent = String(r.queue_size ?? 0);
        latestTagTime = Number(r.last_tag_time || 0);
        latestNumberTime = Number(c.number_time || 0);

        capState.textContent = c.state || "idle";
        capTag.textContent = c.tag || "-";
        const effectiveTag = c.effective_tag || c.resolved_tag || c.tag || "";
        if (effectiveTag) {
          const baseTag = c.tag && c.tag !== effectiveTag ? ` (was ${c.tag})` : "";
          capEffective.textContent = `${effectiveTag}${baseTag}`;
        } else {
          capEffective.textContent = "-";
        }
        const hasTag = !!c.tag;
        capExpected.textContent = hasTag ? (c.label_expected ? c.label_expected : "(no label)") : "-";
        capDetected.textContent = hasTag ? (c.label_detected ? c.label_detected : "-") : "-";
        capAttempt.textContent = String(c.attempt ?? 0);
        capMsg.textContent = c.message || "-";
        const detectedNumber = c.label_detected || c.number || "";
        capNumber.textContent = detectedNumber ? detectedNumber : "-----";

        const secMsg = c.secondary_message || "";
        if (c.state === "running") {
          capSub.textContent = targetDigits ? `Capturing until ${targetDigits} digits...` : "Capturing until target digits...";
        }
        else if (c.state === "awaiting_submit") {
          const mismatch = c.label_match === false;
          const blocked = mismatch && requireLabelMatch;
          let base = "Captured digits. Submit required.";
          if (blocked) {
            base = "Captured digits. Label mismatch; submit blocked.";
          } else if (mismatch) {
            base = "Captured digits. Label mismatch; submit allowed.";
          }
          capSub.textContent = base + (secMsg ? ` Secondary: ${secMsg}` : "");
        }
        else if (c.state === "submitted") capSub.textContent = "Submitted. Ready for next tag." + (secMsg ? ` Secondary: ${secMsg}` : "");
        else if (c.state === "success") capSub.textContent = "Done.";
        else if (c.state === "failed") capSub.textContent = "Failed.";
        else capSub.textContent = "Waiting for approved RFID tag...";

        const awaitingSubmit = !!c.awaiting_submit;
        const labelMismatch = c.label_match === false;
        const blockedByMatch = requireLabelMatch && labelMismatch;
        submitBtn.disabled = !awaitingSubmit || blockedByMatch;

        const labelMessage = c.warning_message || c.label_message || "";
        const warningLines = [];
        let warn = false;
        if (labelMessage) {
          warningLines.push(labelMessage);
          warn = c.label_match === false || (!c.label_expected && labelMessage);
        }
        const connWarnings = [];
        const rfidWarn = buildConnWarning("RFID", r);
        if (rfidWarn) connWarnings.push(rfidWarn);
        const cam1Warn = buildConnWarning("Camera 1", camPrimary);
        if (cam1Warn) connWarnings.push(cam1Warn);
        const cam2Warn = buildConnWarning("Camera 2", camSecondary);
        if (cam2Warn) connWarnings.push(cam2Warn);
        if (connWarnings.length) {
          warningLines.push(connWarnings.join("\n"));
          warn = true;
        }
        if (warningLines.length) {
          capWarning.textContent = warningLines.join("\n");
          capWarning.classList.toggle("warn", warn);
        } else {
          capWarning.textContent = "No warnings.";
          capWarning.classList.remove("warn");
        }

        const savedPath = c.submitted_path || "";
        const prefixHint = c.submitted_prefix ? `${c.submitted_prefix}.json` : "";
        if (awaitingSubmit && blockedByMatch) {
          submitStatus.textContent = "Submit blocked: label mismatch or ambiguous match.";
        } else if (awaitingSubmit) {
          submitStatus.textContent = "Ready to submit captured data.";
        } else if (c.state === "submitted" && (savedPath || prefixHint)) {
          submitStatus.textContent = `Saved: ${savedPath || prefixHint}`;
        } else {
          submitStatus.textContent = "Capture must succeed before submit.";
        }

        const cooldownUntil = Number(c.cooldown_until || 0);
        if (cooldownUntil && data.server_time) {
          const remaining = Math.max(0, Math.round(cooldownUntil - data.server_time));
          const mm = Math.floor(remaining / 60);
          const ss = String(remaining % 60).padStart(2, "0");
          submitStatus.textContent += ` | Tag cooldown ${mm}:${ss}`;
        }

        if (includeImages) {
          imgOriginal.src = c.original_b64 ? "data:image/jpeg;base64," + c.original_b64 : "";
          imgPaper.src = c.paper_b64 ? "data:image/jpeg;base64," + c.paper_b64 : "";
          imgSecondary.src = c.secondary_b64 ? "data:image/jpeg;base64," + c.secondary_b64 : "";
        } else {
          imgOriginal.src = "";
          imgPaper.src = "";
          imgSecondary.src = "";
        }

        renderEvents(data.events || []);

        const rfidState = resolveConnState(r);
        const camPrimaryState = resolveConnState(camPrimary);
        const camSecondaryState = resolveConnState(camSecondary);
        setIndicator(indRfid, rfidState === "off" ? "warn" : rfidState);
        setIndicator(indCamPrimary, camPrimaryState === "off" ? "warn" : camPrimaryState);
        setIndicator(indCamSecondary, camSecondaryState === "off" ? "warn" : camSecondaryState);
        const tagFresh = latestTagTime && data.server_time
          ? (data.server_time - latestTagTime) <= safePresentWindowSeconds
          : false;
        setIndicator(indTag, tagFresh ? "on" : "off");
        const labelDetected = !!(c.label_detected || c.number);
        setIndicator(indLabel, labelDetected ? "on" : "off");
        if (labelDetected && c.label_match === false) {
          setIndicator(indMatch, "warn");
        } else if (labelDetected) {
          setIndicator(indMatch, "on");
        } else {
          setIndicator(indMatch, "off");
        }

        if (beepEnabled) {
          if (lastBeepTagTime === 0 && latestTagTime) {
            lastBeepTagTime = latestTagTime;
          } else if (latestTagTime && latestTagTime > lastBeepTagTime) {
            playBeep(720, 0.07);
            lastBeepTagTime = latestTagTime;
          }
          if (lastBeepLabelTime === 0 && latestNumberTime) {
            lastBeepLabelTime = latestNumberTime;
          } else if (latestNumberTime && latestNumberTime > lastBeepLabelTime) {
            playBeep(980, 0.09);
            lastBeepLabelTime = latestNumberTime;
          }
        }

        if (activeTab === "tags" && listenEnabled && r.enabled) {
          const tag = (r.last_tag || "").trim();
          const tagTime = Number(r.last_tag_time || 0);
          const tagApproved = !!r.last_tag_approved;

          if (tag && tagTime && tagTime > lastScannedTime) {
            lastScannedTime = tagTime;
            tagInput.value = tag;
            tagsStatus.textContent = tagApproved
              ? `Scanned: ${tag} (already approved)`
              : `Scanned: ${tag} (enter label then click Add)`;
          }
        }
      } catch (e) {
        connDot.classList.remove("ok");
        connDot.classList.remove("warn");
        connText.textContent = "Server: not reachable";
        listenBtn.disabled = true;
        capWarning.textContent = "Backend unreachable.";
        capWarning.classList.add("warn");
        setIndicator(indRfid, "warn");
        setIndicator(indCamPrimary, "warn");
        setIndicator(indCamSecondary, "warn");
        setIndicator(indTag, "off");
        setIndicator(indLabel, "off");
        setIndicator(indMatch, "off");
      } finally {
        pollInFlight = false;
      }
    }

    setListening(false);
    refreshTags();
    pollStatus();
    setInterval(pollStatus, safePollIntervalMs);
  </script>
</body>
</html>
